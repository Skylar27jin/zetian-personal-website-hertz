// Code generated by hertz generator.
package base

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol"
	"github.com/cloudwego/hertz/pkg/protocol/consts"

	"zetian-personal-website-hertz/biz/config"
	user "zetian-personal-website-hertz/biz/model/user"
	authService "zetian-personal-website-hertz/biz/service/auth_service"
	"zetian-personal-website-hertz/biz/service/picture_upload_service"
	userService "zetian-personal-website-hertz/biz/service/user_service"
)

/*
All JWTs that are stored in cookie
"JWT": user's basic information

"VeriEmailJWT": means verification email JWT, used to verify user's email for sign up, reset password, etc.
purpose: now we have "signup", "resetpassword", the corresponding VeriEmailJWT should only be used for that purpose.
*/

// Login .
// @router /login [POST]
func Login(ctx context.Context, c *app.RequestContext) {
	var req user.LoginReq
	if err := c.BindAndValidate(&req); err != nil {
		c.String(consts.StatusBadRequest, fmt.Sprintf("Invalid request: %v", err))
		return
	}
	fmt.Println(req.GetEmail(), "password:", req.GetPassword())
	// 验证用户名密码
	domainUser, err := userService.Login(ctx, req.GetEmail(), req.GetPassword())
	if err != nil {
		c.JSON(consts.StatusUnauthorized, user.LoginResp{
			IsSuccessful: false,
			ErrorMessage: err.Error(),
		})
		return
	}

	// 生成 JWT 并设置 Cookie
	token, err := authService.GenerateUserJWT(ctx, -1, int64(domainUser.ID), domainUser.Username, domainUser.Email, -1)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, user.LoginResp{
			IsSuccessful: false,
			ErrorMessage: "JWT generation failed",
		})
		return
	}

	c.SetCookie("JWT",
		token,
		int(3600*24*7),
		"/",
		config.GetSpecificConfig().Domain,
		protocol.CookieSameSiteLaxMode,
		config.GetSpecificConfig().CookieSecure,
		true) // HttpOnly Cookie

	c.JSON(consts.StatusOK, user.LoginResp{
		IsSuccessful: true,
		UserName:     domainUser.Username,
		Email:        domainUser.Email,
	})
}

// SignUp .
// @router /signup [POST]
func SignUp(ctx context.Context, c *app.RequestContext) {
	var req user.SignUpReq
	if err := c.BindAndValidate(&req); err != nil {
		c.String(consts.StatusBadRequest, fmt.Sprintf("Invalid request: %v", err))
		return
	}
	veriEmailJWT := string(c.Cookie("VeriEmailJWT"))

	//verify whether the user has the veriEmail to signUp
	email, veriEmailExp, purpose, err := authService.ParseVeriEmailJWT(ctx, veriEmailJWT)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, user.SignUpResp{
			IsSuccessful: false,
			ErrorMessage: err.Error() + ", Please get verification code first",
		})
		return
	}
	if email != req.GetEmail() || strings.ToLower(purpose) != "signup" {
		c.JSON(consts.StatusUnauthorized, user.SignUpResp{
			IsSuccessful: false,
			ErrorMessage: "Action Unauthorized",
		})
		clearVeriEmailCookie(c)
		return
	}
	if veriEmailExp < time.Now().Unix() {
		c.JSON(consts.StatusUnauthorized, user.SignUpResp{
			IsSuccessful: false,
			ErrorMessage: "The verification code has expired, get a new code first",
		})
		return
	}

	err = userService.SignUp(ctx, req.GetUsername(), req.GetPassword(), req.GetEmail())

	if err != nil {
		c.JSON(consts.StatusBadRequest, user.SignUpResp{
			IsSuccessful: false,
			ErrorMessage: err.Error(),
		})
		return
	}

	c.JSON(consts.StatusOK, user.SignUpResp{
		IsSuccessful: true,
		UserName:     req.GetUsername(),
		Email:        req.GetEmail(),
	})
	//clear the veriEmailJWT, disabling user's ability to modify email
	clearVeriEmailCookie(c)
}

func clearVeriEmailCookie(c *app.RequestContext) {
	c.SetCookie("VeriEmailJWT", "", -1, "/", config.GetSpecificConfig().Domain,
		protocol.CookieSameSiteLaxMode, config.GetSpecificConfig().CookieSecure, true)
}

func clearAuthCookie(c *app.RequestContext) {
	c.SetCookie("JWT", "", -1, "/", config.GetSpecificConfig().Domain,
		protocol.CookieSameSiteLaxMode, config.GetSpecificConfig().CookieSecure, true)
}

// GetUser .
// @router /user/get [GET]
func GetUser(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.GetUserReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	if req.ID < 0 {
		c.JSON(consts.StatusBadRequest, user.GetUserResp{
			IsSuccessful: false,
			ErrorMessage: "ID must be positive",
			UserName:     "",
			ID:           -1,
		})
		return
	}

	if req.ID != 0 && req.Name != "" {
		c.JSON(consts.StatusBadRequest, user.GetUserResp{
			IsSuccessful: false,
			ErrorMessage: "Only one of ID and UserName should be provided",
			UserName:     "",
			ID:           -1,
		})
		return
	}

	if req.ID != 0 {
		domainUser, err := userService.GetUserByID(ctx, req.ID)
		if err != nil {
			c.JSON(consts.StatusInternalServerError, user.GetUserResp{
				IsSuccessful: false,
				ErrorMessage: err.Error(),
				UserName:     "",
				ID:           -1,
			})
			return
		}
		c.JSON(consts.StatusOK, user.GetUserResp{
			IsSuccessful: true,
			ErrorMessage: "",
			UserName:     domainUser.Username,
			ID:           int64(domainUser.ID),
		})
		return
	}

	domainUser, err := userService.GetUserByUsername(ctx, req.Name)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, user.GetUserResp{
			IsSuccessful: false,
			ErrorMessage: err.Error(),
			UserName:     "",
			ID:           -1,
		})
		return
	}
	c.JSON(consts.StatusOK, user.GetUserResp{
		IsSuccessful: true,
		ErrorMessage: "",
		UserName:     domainUser.Username,
		ID:           int64(domainUser.ID),
	})

}

// Logout .
// @router logout [POST]
func Logout(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.LogoutReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	clearAuthCookie(c)
	c.JSON(consts.StatusOK, user.LogoutResp{
		IsSuccessful: true,
		ErrorMessage: "",
	})
}

// ResetPassword .
// @router /user/reset-password [POST]
func ResetPassword(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.ResetPasswordReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	fmt.Println("Request to reset password for email:", req.GetEmail(), "new password:", req.GetNewPassword())
	veriEmailJWT := string(c.Cookie("VeriEmailJWT"))

	//verify whether the user has the veriEmail to signUp
	email, veriEmailExp, purpose, err := authService.ParseVeriEmailJWT(ctx, veriEmailJWT)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, user.ResetPasswordResp{
			IsSuccessful: false,
			ErrorMessage: err.Error() + ", Please get verification code first",
		})
		return
	}
	if email != req.GetEmail() || strings.ToLower(purpose) != "resetpassword" {
		//it means the user is copy pasting JWT from others or from other actions
		c.JSON(consts.StatusUnauthorized, user.ResetPasswordResp{
			IsSuccessful: false,
			ErrorMessage: "Action Unauthorized",
		})
		clearVeriEmailCookie(c)
		return
	}
	if veriEmailExp < time.Now().Unix() {
		c.JSON(consts.StatusUnauthorized, user.ResetPasswordResp{
			IsSuccessful: false,
			ErrorMessage: "The verification code has expired, get a new code first",
		})
		return
	}

	err = userService.ResetPassword(ctx, req.GetEmail(), req.GetNewPassword())
	if err != nil {
		c.JSON(consts.StatusBadRequest, user.ResetPasswordResp{
			IsSuccessful: false,
			ErrorMessage: err.Error(),
		})
		return
	}

	c.JSON(consts.StatusOK, user.ResetPasswordResp{
		IsSuccessful: true,
		ErrorMessage: "",
	})
	//clear the veriEmailJWT, disabling user's ability to modify email
	clearVeriEmailCookie(c)
}

// UpdateAvatar .
// @router /user/update-avatar [POST]
func UpdateAvatar(ctx context.Context, c *app.RequestContext) {
	// 0. 这个接口走 multipart/form-data，不适合 BindAndValidate，就不用 req 了
	// var req user.UpdateAvatarReq
	// if err := c.BindAndValidate(&req); err != nil { ... }

	// 1. JWT 鉴权，拿 userID（和 UploadPostMedia 一样）
	jwtStr := string(c.Cookie("JWT"))
	_, _, _, exp, userID, err := authService.ParseUserJWT(ctx, jwtStr)
	if err != nil {
		fmt.Println("parse JWT error:", err.Error())
	}
	if err != nil || exp < time.Now().Unix() {
		c.JSON(consts.StatusUnauthorized, user.UpdateAvatarResp{
			IsSuccessful: false,
			ErrorMessage: "unauthorized, please login again",
		})
		return
	}

	// 2. 从 multipart/form-data 里拿单个文件：字段名 "avatar"
	fileHeader, err := c.FormFile("avatar")
	if err != nil {
		c.JSON(consts.StatusBadRequest, user.UpdateAvatarResp{
			IsSuccessful: false,
			ErrorMessage: "avatar file is required",
		})
		return
	}

	// 可以简单做点限制（可选）
	if fileHeader.Size > 5*1024*1024 { // 5MB
		c.JSON(consts.StatusBadRequest, user.UpdateAvatarResp{
			IsSuccessful: false,
			ErrorMessage: "avatar file too large (max 5MB)",
		})
		return
	}

	// 3. 调用上传 service：上传到 S3，返回一个 URL
	avatarURL, err := picture_upload_service.UploadAvatar(ctx, userID, fileHeader)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, user.UpdateAvatarResp{
			IsSuccessful: false,
			ErrorMessage: "upload avatar failed: " + err.Error(),
		})
		return
	}

	// 4. 更新 DB 中用户的 avatar_url 字段
	if err := userService.UpdateAvatarURL(ctx, userID, avatarURL); err != nil {
		c.JSON(consts.StatusInternalServerError, user.UpdateAvatarResp{
			IsSuccessful: false,
			ErrorMessage: "update avatar url failed: " + err.Error(),
		})
		return
	}

	// 5. 返回成功
	c.JSON(consts.StatusOK, user.UpdateAvatarResp{
		IsSuccessful: true,
		ErrorMessage: "",
		AvatarUrl:    avatarURL,
	})
}
// FollowUser .
// @router /user/follow [POST]
func FollowUser(ctx context.Context, c *app.RequestContext) {
	var req user.FollowUserReq
	if err := c.BindAndValidate(&req); err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// 1. parse JWT, must be logged in
	jwtStr := string(c.Cookie("JWT"))
	_, _, _, exp, userID, err := authService.ParseUserJWT(ctx, jwtStr)
	if err != nil || exp < time.Now().Unix() {
		c.JSON(consts.StatusUnauthorized, user.FollowUserResp{
			IsSuccessful: false,
			ErrorMessage: "unauthorized, please login first",
		})
		return
	}

	targetID := req.GetTargetUserId()
	if targetID <= 0 {
		c.JSON(consts.StatusBadRequest, user.FollowUserResp{
			IsSuccessful: false,
			ErrorMessage: "invalid target user id",
		})
		return
	}
	if targetID == userID {
		c.JSON(consts.StatusBadRequest, user.FollowUserResp{
			IsSuccessful: false,
			ErrorMessage: "you cannot follow yourself",
		})
		return
	}

	// 2. call service
	if err := userService.FollowUser(ctx, userID, targetID); err != nil {
		c.JSON(consts.StatusBadRequest, user.FollowUserResp{
			IsSuccessful: false,
			ErrorMessage: err.Error(),
		})
		return
	}

	// 3. success
	c.JSON(consts.StatusOK, user.FollowUserResp{
		IsSuccessful: true,
		ErrorMessage: "",
	})
}

// UnfollowUser .
// @router /user/unfollow [POST]
func UnfollowUser(ctx context.Context, c *app.RequestContext) {
	var req user.UnfollowUserReq
	if err := c.BindAndValidate(&req); err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// 1. parse JWT, must be logged in
	jwtStr := string(c.Cookie("JWT"))
	_, _, _, exp, userID, err := authService.ParseUserJWT(ctx, jwtStr)
	if err != nil || exp < time.Now().Unix() {
		c.JSON(consts.StatusUnauthorized, user.UnfollowUserResp{
			IsSuccessful: false,
			ErrorMessage: "unauthorized, please login first",
		})
		return
	}

	targetID := req.GetTargetUserId()
	if targetID <= 0 {
		c.JSON(consts.StatusBadRequest, user.UnfollowUserResp{
			IsSuccessful: false,
			ErrorMessage: "invalid target user id",
		})
		return
	}
	if targetID == userID {
		c.JSON(consts.StatusBadRequest, user.UnfollowUserResp{
			IsSuccessful: false,
			ErrorMessage: "you cannot unfollow yourself",
		})
		return
	}

	// 2. call service
	if err := userService.UnfollowUser(ctx, userID, targetID); err != nil {
		c.JSON(consts.StatusBadRequest, user.UnfollowUserResp{
			IsSuccessful: false,
			ErrorMessage: err.Error(),
		})
		return
	}

	// 3. success
	c.JSON(consts.StatusOK, user.UnfollowUserResp{
		IsSuccessful: true,
		ErrorMessage: "",
	})
}

// GetUserProfile .
// @router /user/profile [GET]
func GetUserProfile(ctx context.Context, c *app.RequestContext) {
	var req user.GetUserProfileReq
	if err := c.BindAndValidate(&req); err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	targetID := req.GetID()
	if targetID <= 0 {
		c.JSON(consts.StatusBadRequest, user.GetUserProfileResp{
			IsSuccessful: false,
			ErrorMessage: "invalid target user id",
		})
		return
	}

	// viewerID is optional: if JWT ok -> real user, otherwise treat as guest (0)
	var viewerID int64 = 0
	if jwtBytes := c.Cookie("JWT"); len(jwtBytes) > 0 {
		jwtStr := string(jwtBytes)
		_, _, _, exp, uid, err := authService.ParseUserJWT(ctx, jwtStr)
		if err == nil && exp >= time.Now().Unix() {
			viewerID = uid
		}
	}

	// 1. call service to build profile
	profile, err := userService.GetUserProfile(ctx, viewerID, targetID)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, user.GetUserProfileResp{
			IsSuccessful: false,
			ErrorMessage: err.Error(),
		})
		return
	}

	// 2. map domain.UserProfile -> thrift user.UserProfile
	respUser := &user.UserProfile{
		ID:                    profile.Id,
		UserName:              profile.UserName,
		AvatarUrl:             profile.AvatarUrl,
		FollowersCount:        profile.FollowersCount,
		FollowingCount:        profile.FollowingCount,
		PostLikeReceivedCount: profile.PostLikeReceivedCount,
		IsFollowing:           profile.IsFollowing,
		IsMe:                  profile.IsMe,
	}

	// 3. success
	c.JSON(consts.StatusOK, user.GetUserProfileResp{
		IsSuccessful: true,
		ErrorMessage: "",
		User:         respUser,
	})
}
